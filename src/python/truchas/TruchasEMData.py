#===============================================================================
#
# This file is part of Truchas. 3-Clause BSD license; see the LICENSE file.
#
#===============================================================================

import re
import os
import sys

import h5py
import numpy as np

from . import truchas_geometry as tg


class TruchasEMData:
    """A class for reading Truchas EM output data.

    This class currently makes the following assumptions:

    1. The EM mesh is tetrahedral.
    2. All output data is cell-centered.
    3. There is only a single EM output.

    :param filename: Filename of the Truchas h5 output file.
    :type filename: str
    """

    def __init__(self, filename):
        self.filename = filename
        """The filename of the HDF5 Truchas output."""
        self.directory = os.path.dirname(filename)
        self._root = h5py.File(filename, 'r')
        self._centroid = None
        self._volume = None
        self._node_coordinates = None
        self._cnode = None

        self.ncell = self._root["VTKHDF/NumberOfCells"][0]
        self.nnode = self._root["VTKHDF/NumberOfPoints"][0]

        self._compute_maps()


    def field(self, field_name):
        """Return the requested field as a ndarray. This will read the entire
        field from disk.

        :param field_name: The name of a field in the Truchas output file. Valid
            values include ``"E_im"``, ``"E_re"``, ``"H_im"``, ``"H_re"``,
            ``"|E|"``, ``"|H|"``, ``"Q_EM"``, ``"MPI rank"``.
        :type field_name: str

        :return: The requested field from the H5 file. If the field has been
            reassigned, returns the user-defined copy.
        :rtype: :class:`numpy.ndarray`

        """
        field = self._root[f"VTKHDF/CellData/{field_name}"][:][self._cellmap]
        return field


    def _cell_node_map(self):
        """Load the cnode map."""
        if self._cnode is None:
            cnode = self._root["VTKHDF/Connectivity"][:]
            xcnode = self._root["VTKHDF/Offsets"][:]
            self._cnode = np.array([cnode[xcnode[i]:xcnode[i+1]] for i in range(len(xcnode)-1)])
        return self._cnode


    def _compute_maps(self):
        """Compute a processor-independent mapping of the data. NB: This mapping
        is orientation-dependent, since it is generated by sorting the cell
        centroids.
        """
        xn = self.node_coordinates()
        self._nodemap = np.argsort(xn.view(dtype="f8,f8,f8"), axis=0, order=["f0","f1","f2"])[:,0]
        self._node_coordinates = self._node_coordinates[self._nodemap]

        inodemap = np.argsort(self._nodemap)
        self._cell_node_map()
        self._cnode = np.sort(inodemap[self._cnode])
        self._cellmap = np.argsort(self._cnode.view("i8,i8,i8,i8"), axis=0,
                                   order=["f0","f1","f2","f3"])[:,0]
        self._cnode = self._cnode[self._cellmap]


    def centroids(self):
        """
        :return: A ``[ncell,3]`` field of cell centroids.
        :rtype: :class:`numpy.ndarray`
        """
        if self._centroid is None:
            x = self.node_coordinates()
            cnode = self._cell_node_map()
            self._centroid = np.array([np.average(x[cn,:], axis=0) for cn in cnode])
        return self._centroid


    def volumes(self):
        """
        :return: A length ``ncell`` field of cell volumes.
        :rtype: :class:`numpy.ndarray`
        """
        if self._volume is None:
            x = self.node_coordinates()
            cnode = self._cell_node_map()
            self._volume = np.array([tg.tet_volume(x[cn,:]) for cn in cnode])
            self._volume = self._volume[self._cellmap]
        return self._volume


    def node_coordinates(self):
        """
        :return: A ``[nnode,3]`` field of node coordinates.
        :rtype: :class:`numpy.ndarray`
        """
        if self._node_coordinates is None:
            self._node_coordinates = self._root["VTKHDF/Points"][:]
        return self._node_coordinates
