!!
!! IH_HFIELD_FACTORY_TYPE
!!
!! This module defines a derived type that encapsulates the time-dependent
!! parameters defining an external alternating magnetic field generated by
!! induction coils, with a factory method that creates function objects for
!! the evaluation of the field. This magnetic field will serve as the driving
!! force in the computation of Joule heat in induction heating simulations,
!! entering the equations in the nxH boundary condition.
!!
!! Neil Carlson <neil.n.carlson@gmail.com>
!! Refactored February 2024
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!! This file is part of Truchas. 3-Clause BSD license; see the LICENSE file.
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!! The external source is the superposition of a uniform periodic background
!! field and the periodic fields due to a collection of current loops carrying
!! alternating currents, all having the same frequency and phase. Over the
!! much longer time scale of heat transfer, this rapidly varying external
!! source may change at discrete times in "piecewise-constant" manner. Hence
!! the need for this type with factory methods capable of creating abstract
!! field functions on demand at any given induction heating simulation time.
!!

module ih_hfield_factory_type

  use,intrinsic :: iso_fortran_env, only: r8 => real64
  use scalar_func_class
  use vector_func_class
  use ih_hfield_func_type
  implicit none
  private

  type, public :: ih_hfield_factory
    private
    real(r8), allocatable, public :: times(:)
    real(r8), allocatable :: freq(:), const_src(:), current(:,:)
    type(induction_coil), allocatable :: coil(:)
    character(1) :: axis
  contains
    procedure :: init
    procedure :: frequency, angular_freq
    procedure :: update_ih_hfield_func
    procedure :: hfield_is_zero
    generic :: hfield_differs => hfield_differs1, hfield_differs2
    procedure, private :: hfield_differs1, hfield_differs2
    generic :: hfield_is_scaled => hfield_is_scaled1, hfield_is_scaled2
    procedure, private :: hfield_is_scaled1, hfield_is_scaled2
    procedure :: hfield_data
    procedure :: coil_geom_fingerprint
    procedure, private :: data_index
  end type

  !! Custom SCALAR_FUNC extension that implements the time-periodic
  !! waveform factor for the magnetic field source.
  type, extends(scalar_func), private :: waveform_func
    real(r8) :: freq
  contains
    procedure :: eval => waveform
  end type

contains

  subroutine init(this, params, stat, errmsg)

    use parameter_list_type
    use string_utilities, only: i_to_c

    class(ih_hfield_factory), intent(out) :: this
    type(parameter_list), intent(inout) :: params
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg

    integer :: i, n
    real(r8), allocatable :: array(:)
    type(parameter_list), pointer :: plist
    type(parameter_list_iterator) :: piter
    character(:), allocatable :: axis

    !TODO: For case where source-times is not specified should we expect scalar
    ! values for frequency, uniform-strength, and coil current rather than
    ! size-1 arrays?

    if (params%is_parameter('times')) then
      call params%get('times', this%times, stat, errmsg)
      if (stat /= 0) return
      n = size(this%times)
      if (n > 1) then
        if (any(this%times(2:n) <= this%times(:n-1))) then
          stat = 1
          errmsg = 'times values not strictly increasing'
          return
        end if
      end if
    else
      allocate(this%times(0))
      n = 0
    end if

    call params%get('frequency', this%freq, stat, errmsg)
    if (stat /= 0) return
    if (any(this%freq <= 0.0_r8)) then
      stat = 1
      errmsg = 'frequency is <= 0.0'
      return
    else if (size(this%freq) /= n+1) then
      stat = 1
      errmsg = 'expect ' // i_to_c(n+1) // ' values for frequency'
      return
    endif

    call params%get('uniform-strength', this%const_src, stat, errmsg, default=spread(0.0_r8,1,n+1))
    if (stat /= 0) return
    if (size(this%const_src) /= n+1) then
      stat = 1
      errmsg = 'expect ' // i_to_c(n+1) // ' values for uniform-strength'
      return
    endif

    plist => params%sublist('coils')
    piter = parameter_list_iterator(plist, sublists_only=.true.)
    allocate(this%coil(piter%count()), this%current(piter%count(),n+1))
    do i = 1, size(this%coil)
      plist => piter%sublist()
      associate (coil => this%coil(i))
        call plist%get('center', array, stat, errmsg, default=spread(0.0_r8,1,3))
        if (stat /= 0) return
        if (size(array) /= 3) then
          stat = 1
          errmsg = piter%name() //': center requires a 3-vector value'
          return
        else
          coil%center = array
        end if
        call plist%get('radius', coil%radius, stat, errmsg)
        if (stat /= 0) return
        if (coil%radius <= 0.0_r8) then
          stat = 1
          errmsg = piter%name() // ': radius is <= 0.0'
          return
        end if
        call plist%get('num-loops', coil%nloop, stat, errmsg)
        if (stat /= 0) return
        if (coil%nloop <= 0) then
          stat = 1
          errmsg = piter%name() // ': num-loops is <= 0'
          return
        end if
        if (coil%nloop > 1) then
          call plist%get('length', coil%length, stat, errmsg)
          if (stat /= 0) return
          if (coil%length <= 0) then
            stat = 1
            errmsg = piter%name() // ': length is <= 0'
            return
          end if
        else
          coil%length = 0.0_r8
        end if
        call plist%get('current', array, stat, errmsg)
        if (stat /= 0) return
        if (size(array) /= n+1) then
          stat = 1
          errmsg = piter%name() // ': expect ' // i_to_c(n+1) // ' values for current'
          return
        end if
        this%current(i,:) = array
      end associate
      call piter%next
    end do

    call params%get('orientation', axis, stat, errmsg, default='Z')
    if (stat /= 0) return
    select case (axis)
    case ('x','X','y','Y','z','Z')
      this%axis = axis
    case default
      stat = 1
      errmsg = 'invalid value for orientation: ' // axis
      return
    end select

  end subroutine init

  !! Return the frequency of the induction field at time T
  real(r8) function frequency(this, t)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: t
    frequency = this%freq(this%data_index(t))
  end function

  !! Return the angular frequency of the induction field at time T.
  pure real(r8) function angular_freq(this, t)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: t
    real(r8), parameter :: TWOPI = 8*atan(1.0_r8)
    angular_freq = TWOPI*this%freq(this%data_index(t))
  end function

  subroutine update_ih_hfield_func(this, t)

    use func_table, only: insert_func

    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: t

    integer :: i
    class(scalar_func), allocatable :: f
    class(vector_func), allocatable :: g
    type(ih_hfield_func), allocatable :: gtmp

    i = this%data_index(t)
    allocate(f, source=waveform_func(this%freq(i)))
    call insert_func('_ih_waveform', f)

    allocate(gtmp)
    call gtmp%init(this%axis, this%const_src(i), this%coil, this%current(:,i))
    call move_alloc(gtmp, g)
    call insert_func('_ih_profile', g)

  end subroutine

  !! An auxiliary function that locates the IH time interval containing time T.
  pure integer function data_index(this, t) result(n)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: t
    n = size(this%times)
    do while (n > 0)
      if (t >= this%times(n)) exit
      n = n - 1
    end do
    n = n + 1
  end function

  !! Return an array [FREQ, CONST, CURRENTS] of the parameters defining the
  !! source at the given IH time T. These are the frequency, the strength
  !! of the uniform background field and the currents in the coils. Client
  !! code should use this only as a fingerprint of the source, for use as
  !! input to the HFIELD_DIFFERS and HFIELD_IS_SCALED methods.

  function hfield_data(this, t) result(src_data)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: t
    real(r8), allocatable :: src_data(:)
    integer :: n
    n = this%data_index(t)
    src_data = [this%freq(n), this%const_src(n), this%current(:,n)]
  end function

  !! Return true if the source is 0 at the given IH time T; otherwise false.

  logical function hfield_is_zero(this, t)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: t
    real(r8), allocatable :: d(:)
    d = this%hfield_data(t)
    hfield_is_zero = all(d(2:) == 0.0_r8)
  end function

  !! Return true if the source at IH times T1 and T2 differ; otherwise false.
  !! This is a specific function for the generic HFIELD_DIFFERS.

  logical function hfield_differs1(this, t1, t2) result(differs)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: t1, t2
    differs = this%hfield_differs(this%hfield_data(t1), t2)
  end function

  !! Return true if the source at IH time T2 differs from the source with
  !! fingerprint D1, as returned by HFIELD_DATA. This is a specific function
  !! for the generic HFIELD_DIFFERS.

  logical function hfield_differs2(this, d1, t2) result(differs)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in) :: d1(:), t2
    real(r8), allocatable :: d2(:)
    d2 = this%hfield_data(t2)
    associate (f1 => d1(1), u1 => d1(2:), f2 => d2(1), u2 => d2(2:))
      differs = .true.
      if (any(u1 /= u2)) return
      if (any(u1 /= 0.0_r8) .and. f1 /= f2) return
      differs = .false.
    end associate
  end function

  !! Return true if the source at IH time T2 is a multiple of the source
  !! at IH time T1, and return the scale factor in the argument SCF. This
  !! is a specific function for the generic HFIELD_IS_SCALED.

  logical function hfield_is_scaled1(this, t1, t2, scf) result(scaled)
    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in)  :: t1, t2
    real(r8), intent(out) :: scf
    scaled = this%hfield_is_scaled(this%hfield_data(t1), t2, scf)
  end function hfield_is_scaled1

  !! Return true if the source strength at IH time T2 is a multiple of the
  !! strength of the source with fingerprint D1, as returned by HFIELD_DATA,
  !! and return the scale factor in the argument SCF. This is a specific
  !! function for the generic HFIELD_IS_SCALED. NB: A relatively arbitrary
  !! tolerance is used to decide between scaled and not-scaled.

  logical function hfield_is_scaled2(this, d1, t2, scf) result(scaled)

    class(ih_hfield_factory), intent(in) :: this
    real(r8), intent(in)  :: d1(:), t2
    real(r8), intent(out) :: scf

    real(r8) :: a, err
    real(r8), allocatable :: d2(:)

    d2 = this%hfield_data(t2)

    associate (f1 => d1(1), u1 => d1(2:), f2 => d2(1), u2 => d2(2:))
      ! Best scale factor in least-squares sense
      a = norm2(u1)
      if (a > 0.0_r8) then
        scf = dot_product(u1,u2) / a**2
      else
        scf = 0.0_r8
      end if
      err = norm2(u2-scf*u1) ! l2 error in best scaling
      scaled = (f1 == f2) .and. (err <= a*1.0e-6)
    end associate

  end function hfield_is_scaled2

  !! Returns the MD5 checksum of the source parameters that define the fixed
  !! geometry of the source which are invariant in an induction heating
  !! simulation. These are the symmetry axis and the parameters defining the
  !! geometry of the coils. This is useful for tagging joule heat data in
  !! checkpoints to ensure that the source geometry in restarts has not
  !! changed.

  function coil_geom_fingerprint(this) result(fp)
    use secure_hash_factory
    class(ih_hfield_factory), intent(in) :: this
    character(:), allocatable :: fp
    integer :: n
    class(secure_hash), allocatable :: hash
    call new_secure_hash(hash, 'md5')
    do n = 1, size(this%coil)
      call hash%update(this%coil(n)%length)
      call hash%update(this%coil(n)%radius)
      call hash%update(this%coil(n)%center)
      call hash%update(this%coil(n)%nloop)
    end do
    call hash%update(this%axis)
    fp = hash%hexdigest()
  end function

  !! The type-bound EVAL function for the WAVEFORM_FUNC extension of the
  !! SCALAR_FUNC class. This is a (1/freq)-periodic waveform function with
  !! initial fade-in to full strength. There are several potential options
  !! for the waveform, but it is currently hardwired to a simple sinusoid.

  function waveform(this, x) result(fx)
    class(waveform_func), intent(in) :: this
    real(r8), intent(in) :: x(:)
    real(r8) :: fx, wt
    real(r8), parameter :: PI = 4*atan(1.0_r8)
    associate (t => x(1))
      wt = 2*PI*this%freq*t
      select case (0)
      case (1)  ! Truncated l2 fit to a square wave
        fx = (sin(wt)+sin(3*wt)/3.0+sin(5*wt)/5.0+sin(7*wt)/7.0)*(4.0/PI)
      case (2)  ! Non-oscillatory 'square' wave
        fx = (1225*sin(wt)+245*sin(3*wt)+49*sin(5*wt)+5*sin(7*wt))/1024.0
      case default ! Basic sinusoidal wave form.
        fx = sin(wt)
      end select
      fx = (1.0_r8 - exp(-2.0_r8*(this%freq*t)**2))*fx
    end associate
  end function

end module ih_hfield_factory_type
