!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!! This file is part of Truchas. 3-Clause BSD license; see the LICENSE file.
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#include "f90_assert.fpp"

MODULE MATL_UTILITIES

  use,intrinsic :: iso_fortran_env, only: r8 => real64
  IMPLICIT NONE
  private

  public :: MATL_GET_VOF  ! These two enable removing Matl from the volume tracker.
  public :: define_matl, read_matl_data, matl_get_cell_vof

CONTAINS

  SUBROUTINE MATL_GET_VOF (VOF)
    ! ==========================================================================
    ! Sriram originally wrote the skeleton for a routine that would allow access
    ! to any part of Matl.  But I don't think that that'll every be necessary,
    ! as the only part that's really used much are the current Vof values.  And
    ! so I've taken the liberty of simplifying this to a routine that fills an
    ! array (nmat,ncells) with current VOF values.
    !
    ! Written by:
    ! Markus Bussmann (University of Toronto)
    !===========================================================================
    use matl_module, only: Matl, ncells, nmat, mat_slot

    ! Arguments
    real(r8), dimension(nmat,ncells), intent(INOUT) :: VOF

    ! Local Variables
    integer :: m, n, s

    VOF = 0.0_r8

    do n = 1,ncells
       do s = 1,mat_slot
          m = Matl(s)%Cell(n)%Id
          if (m > 0) then
             VOF(m,n) = Matl(s)%Cell(n)%Vof
          end if
       end do
    end do

  END SUBROUTINE MATL_GET_VOF
  
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!
 !! MATL_GET_CELL_VOF
 !!
 !! Neil Carlson <nnc@lanl.gov> 28 Jul 2009
 !!
 !! Returns the material volume fractions for cell N in the array VOF.
 !!

  subroutine matl_get_cell_vof (n, vof)
  
    use matl_module, only: matl, ncells, nmat, mat_slot
    
    integer, intent(in) :: n
    real(r8), intent(out) :: vof(:)
    
    integer :: s, m
    
    ASSERT(size(vof) == nmat)
    ASSERT(n >= 1 .and. n <= ncells)
    
    vof = 0.0
    do s = 1, mat_slot
      m = matl(s)%cell(n)%id
      if (m > 0) vof(m) = matl(s)%cell(n)%vof
    end do
    
  end subroutine matl_get_cell_vof

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!
 !! DEFINE_MATL
 !!
 !! Neil Carlson <nnc@lanl.gov>
 !! 14 Apr 2005
 !!
 !! Given the volume fraction array VF, covering all materials and cells, this
 !! routine initializes the data in the MATL structure.  The first index of
 !! the VF array is the material index, and the second is the cell index.
 !!
 !! NB: MATL is intent(inout) because it has pointer components that may be
 !! associated.  None of its values are used, however, and all are overwritten.
 !!

  subroutine define_matl (vf)

    use matl_module, only: matl, material, slot_resize, ncells, nmat, mat_slot
    use parallel_communication, only: global_maxval

    real(r8), intent(in)    :: vf(:,:)

    integer :: j, m, s
    type(material) :: null_mat  ! This is default initialized.
    type(material), allocatable :: mlist(:)

    ASSERT( size(vf,1) <= nmat )
    ASSERT( size(vf,2) == ncells )

    !! Find the max number of materials in any one cell and resize MATL accordingly.
    m = global_maxval(count(vf > 0.0_r8, dim=1))
    call slot_resize (matl, mat_slot, m)

    !! Set up the material list; only the VOF values change from cell to cell.
    allocate(mlist(size(vf,1)))  ! This is default initialized.
    do m = 1, size(mlist)
      mlist(m)%ID  = m
    end do

    !! Define MATL.
    do j = 1, ncells
      mlist%vof = vf(:,j) ! stuff in the VF values for this cell.
      !! Pack the valid part of the material list into MATL; can't use the pack intrinsic :(
      s = 1
      do m = 1, size(mlist)
        if (vf(m,j) <= 0.0_r8) cycle
        matl(s)%cell(j) = mlist(m)
        s = s + 1
      end do
      !! Fill the rest of MATL with null material data.
      do s = s, mat_slot
        matl(s)%cell(j) = null_mat
      end do
    end do

    deallocate(mlist)

  end subroutine define_matl

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!
 !! READ_MATL_DATA
 !!
 !! Neil N. Carlson <nnc@lanl.gov>
 !! 18 Apr 2005
 !!
 !! This subroutine reads the volume fraction data from a restart file opened
 !! (and pre-positioned) on UNIT, and uses this data (properly distributed and
 !! permuted) to define the module structure MATL.  VERSION is the version
 !! number of the restart file format.
 !!
 !! NB: It is implicitly assumed that the material indices in the restart file
 !! directly correspond to the material indices generated by the input file.
 !! We require that the number of materials agree between the input and restart
 !! files; this constraint could probably be relaxed to allow the input to
 !! specify more (new additional) materials.
 !!

  subroutine read_matl_data (unit, version)

    use matl_module, only: nmat
    use restart_utilities, only: read_var, read_dist_array, halt
    use string_utilities, only: i_to_c
    use base_mesh_class
    use mesh_manager, only: named_mesh_ptr

    integer, intent(in) :: unit, version

    integer :: n
    real(r8), allocatable :: vf(:,:)
    class(base_mesh), pointer :: mesh

    mesh => named_mesh_ptr('MAIN')
    INSIST(associated(mesh))

    !! Read the number of materials defined in the restart file.
    call read_var (unit, n, 'READ_MATL_DATA: error reading NMAT record')
    if (n /= nmat) call halt ('READ_MATL_DATA: incompatible NMAT value: ' // i_to_c(n))

    !! Read the volume fraction array.
    allocate(vf(n,mesh%ncell_onP))
    call read_dist_array (unit, vf, mesh%xcell(:mesh%ncell_onP), 'READ_MATL_DATA: error reading VF records')

    !! Derive the MATL structure from the volume fraction array.
    call define_matl (vf)
    deallocate(vf)

  end subroutine read_matl_data

END MODULE MATL_UTILITIES
